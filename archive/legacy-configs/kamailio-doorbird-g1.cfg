#!KAMAILIO
#
# DoorBird -> 2x Gira G1 SIP proxy (forking) on Raspberry Pi.
# Goal: keep SDP/media end-to-end (DoorBird <-> answering G1) and only proxy SIP signaling.
#
# Listens on UDP 5080 on the Pi and forks INVITE for extension 7000 to both G1 panels.
#

#!define PI_IP "192.168.11.180"
#!define LISTEN_PORT "5080"
#!define G1_A "192.168.11.23"
#!define G1_B "192.168.11.53"

####### Global Parameters #########

debug=2
log_stderror=no

memdbg=5
memlog=5

children=4

# NOTE: Kamailio does not expand the preprocessor defines in the `listen=` directive
# reliably (parser expects a literal IP/interface/hostname). Keep this literal.
listen=udp:192.168.11.180:5080
listen=udp:192.168.11.180:5095

####### Modules Section ########

# Module load order matters, especially for tm (transaction module).
# Anything that relies on tm must be loaded after tm.
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "maxfwd.so"
loadmodule "pv.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "rtpengine.so"

modparam("tm", "pass_provisional_replies", 1)
modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:2223")

####### Routing Logic ########

route {
	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483", "Too Many Hops");
		exit;
	}

	# We don't do auth here; this is LAN-only.
	if (is_method("REGISTER")) {
		sl_send_reply("200", "OK");
		exit;
	}

	if (is_method("OPTIONS")) {
		sl_send_reply("200", "OK");
		exit;
	}

	# In-dialog requests.
	if (has_totag()) {
		if (loose_route()) {
			if (is_method("BYE")) {
				rtpengine_delete();
			} else if (has_body("application/sdp")) {
				rtpengine_manage("replace-origin replace-session-connection via-branch=auto");
			}
			t_relay();
			exit;
		}
		sl_send_reply("404", "Not here");
		exit;
	}

	# Ensure the proxy stays on the signaling path.
	if (is_method("INVITE")) {
		record_route();
	}

	# Forward CANCEL to all branches.
	if (is_method("CANCEL")) {
		t_relay();
		exit;
	}

	# Variant-2 POC ingress:
	# DoorBird -> Kamailio:5095, Kamailio forks to two dedicated
	# Asterisk single-leg contexts (7701/7702) on :5090.
	# Some DoorBird profiles send INVITE to user "doorbird" for checks.
	if (is_method("INVITE") && ($rU == "7700" || $rU == "doorbird")) {
		xlog("L_INFO", "variant2-fork: INVITE to $rU from $si:$sp callid=$ci\n");
		t_on_failure("DB_FAIL");
		$ru = "sip:7702@192.168.11.180:5090";
		$du = "sip:192.168.11.180:5090";
		if (!append_branch()) {
			xlog("L_ERR", "variant2-fork: append_branch to 7702 failed callid=$ci\n");
		}
		$ru = "sip:7701@192.168.11.180:5090";
		$du = "sip:192.168.11.180:5090";
		t_relay();
		exit;
	}

	# Explicit single-leg route to G1_23 (used by Asterisk 7620 leg A).
	if (is_method("INVITE") && $rU == "7000") {
		xlog("L_INFO", "doorbird-single: INVITE to 7000 -> G1_23 from $si:$sp callid=$ci\n");
		if (has_body("application/sdp")) {
			if (!rtpengine_offer("replace-origin replace-session-connection")) {
				xlog("L_WARN", "doorbird-single: rtpengine_offer failed for G1_23 callid=$ci\n");
			}
		}
		t_on_reply("DB_REPLY");
		t_on_failure("DB_FAIL");
		$ru = "sip:7000@192.168.11.23:5060";
		$du = "sip:192.168.11.23:5060";
		t_relay();
		exit;
	}

	# Explicit single-leg route to G1_53 (used by Asterisk 7620 leg B).
	if (is_method("INVITE") && $rU == "7002") {
		xlog("L_INFO", "doorbird-single: INVITE to 7002 -> G1_53 from $si:$sp callid=$ci\n");
		if (has_body("application/sdp")) {
			if (!rtpengine_offer("replace-origin replace-session-connection")) {
				xlog("L_WARN", "doorbird-single: rtpengine_offer failed for G1_53 callid=$ci\n");
			}
		}
		t_on_reply("DB_REPLY");
		t_on_failure("DB_FAIL");
		$ru = "sip:7000@192.168.11.53:5060";
		$du = "sip:192.168.11.53:5060";
		t_relay();
		exit;
	}

	# Legacy downstream fork route (kept for comparison tests).
	if (is_method("INVITE") && $rU == "7001") {
		xlog("L_INFO", "doorbird-fork: INVITE to $rU from $si:$sp callid=$ci\n");

		# Do NOT create an initial non-branch media leg here.
		# In forked calls we anchor media per-branch in DB_BRANCH.
		t_on_branch("DB_BRANCH");
		t_on_reply("DB_REPLY");
		t_on_failure("DB_FAIL");

		# Important: the branch next-hop (Destination-URI, $du) must differ per target.
		# We observed that using append_branch("sip:...@53") can still keep the same
		# next-hop and send both INVITEs to the same IP. So we create the 2nd branch
		# by setting both $ru and $du and calling append_branch() without arguments.
		$ru = "sip:7000@192.168.11.53:5060";
		$du = "sip:192.168.11.53:5060";
		if (append_branch()) {
			xlog("L_INFO", "doorbird-fork: branch2 ru=$ru du=$du\n");
		} else {
			xlog("L_ERR", "doorbird-fork: append_branch() failed for 192.168.11.53\n");
		}

		# Set branch1 as the current R-URI/D-URI for t_relay().
		$ru = "sip:7000@192.168.11.23:5060";
		$du = "sip:192.168.11.23:5060";
		xlog("L_INFO", "doorbird-fork: branch1 ru=$ru du=$du\n");

		t_relay();
		exit;
	}

	sl_send_reply("404", "Not Found");
}

branch_route[DB_BRANCH] {
	if (is_method("INVITE") && has_body("application/sdp")) {
		if (!rtpengine_offer("replace-origin replace-session-connection via-branch=auto-next")) {
			xlog("L_WARN", "doorbird-fork: branch rtpengine_offer failed ru=$ru du=$du callid=$ci\n");
		}
	}
}

onreply_route[DB_REPLY] {
	if (is_method("INVITE") && status=~"^(18[0-9]|2[0-9][0-9])$" && has_body("application/sdp")) {
		if (!rtpengine_answer("replace-origin replace-session-connection via-branch=auto")) {
			xlog("L_WARN", "doorbird-fork: rtpengine_answer failed code=$rs callid=$ci\n");
		}
	}
}

failure_route[DB_FAIL] {
	if (!t_is_canceled()) {
		rtpengine_delete();
	}
}
